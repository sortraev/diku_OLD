# -*- mode: ruby -*-
# vi: set ft=ruby :

# First we define two (large multiline) strings, $script and $msg, to be
# used later

$script = <<-'SCRIPT'
set -xe
export DEBIAN_FRONTEND=noninteractive
apt-get -qq update
apt-get -qq upgrade -y
apt-get -qq install -y apt-transport-https ca-certificates curl \
        software-properties-common \
        nasm zip gdb strace binutils build-essential \
        manpages-posix-dev manpages-posix \
        vim emacs-nox nano bash-completion git \
        python3-dev python3-pip \
        curl wget gcc-multilib g++-multilib clang \
        sl lolcat socat cowsay cowsay-off filters bsdgames \
        afl++ afl++-clang afl++-doc radare2 zzuf

# If we want GDB to be able to attach to an other process we
# need to switch off some kernel hardening.
# We do this by changing the ptrace scope from one to zero
sed -i 's/kernel.yama.ptrace_scope = 1/kernel.yama.ptrace_scope = 0/' /etc/sysctl.d/10-ptrace.conf

# We then need to restart the relevant service
sysctl -p /etc/sysctl.d/10-ptrace.conf

# Disable Canonical phone-home motd
#sed -i 's/ENABLED=1/ENABLED=0/' /etc/default/motd-news

# compile and install runshellcode tool, a PCS specific program for running shellcode
echo Installing runshellcode program
cat <<'EOF' > /tmp/runshellcode.c
#include <sys/types.h>
#include <sys/stat.h>
#include <sys/mman.h>
#include <stdlib.h>
#include <fcntl.h>
#include <unistd.h>
#include <stdio.h>
#include <string.h>

int main(int argc, char **argv) {
  char *stack_space[0x1000];
  int fd;
  struct stat sbuf;
  void (*shellcode)(void);
  int i, z, c, bufsize, numb;
  unsigned char *p;
  if (argc < 2) {
    fprintf(stderr, "Usage: %s (<filename>|-)\n", argv[0]);
    return EXIT_FAILURE;
  }

  if (strcmp(argv[1], "-") == 0) {
    bufsize = 4096;
    p = malloc(bufsize);
    z = 0;
    numb = 0;
    while ((c = getchar()) != EOF) {
      if (numb == bufsize) {
        bufsize += 4096;
        p = realloc(p, bufsize);
      }
      p[numb++] = c;
      if (c == '\0') z++;
    }

    if ((shellcode = mmap(NULL, numb, PROT_READ | PROT_EXEC | PROT_WRITE,
                          MAP_ANONYMOUS | MAP_PRIVATE, -1, 0)) == MAP_FAILED) {
      perror("mmap() failed");
      return EXIT_FAILURE;
    }
    memcpy(shellcode, p, numb);
    free(p);
  } else {
    if ((fd = open(argv[1], O_RDONLY)) < 0) {
      perror("open() failed");
      return EXIT_FAILURE;
    }
    if (fstat(fd, &sbuf)) {
      perror("fstat() failed");
      return EXIT_FAILURE;
    }
    if ((shellcode = mmap(NULL, sbuf.st_size, PROT_READ | PROT_EXEC | PROT_WRITE,
                          MAP_PRIVATE, fd, 0)) == MAP_FAILED) {
      perror("mmap() failed");
      return EXIT_FAILURE;
    }

    close(fd);
    for (i = 0, z = 0, p = (void *)shellcode; i < sbuf.st_size; i++) {
      if (p[i] == '\0') z++;
    }
    numb = sbuf.st_size;
  }

  argc--;
  for (i = 0; i < argc; i++) {
    argv[i] = argv[i + 1];
  }

  printf("Read %d bytes of shell code. Here goes.\n", numb);
  if (z > 0) printf("Shellcode contains %d zero bytes.\n", z);
  printf("~~~ Running shellcode ~~~\n");

  shellcode();

  /* should not be reached */
  return EXIT_FAILURE;
}
EOF
cd /tmp
gcc -z execstack -fno-stack-protector runshellcode.c -o /usr/bin/runshellcode -m64
gcc -z execstack -fno-stack-protector runshellcode.c -o /usr/bin/runshellcode32 -m32



SCRIPT

$msg = <<~MSG
------------------------------------------------------
The PCS VM is ready

Get ssh access with the command
    vagrant ssh

The files in the current directory can be found
in the /vagrant directory
------------------------------------------------------
MSG

Vagrant.configure(2) do |config|

  # Every Vagrant virtual environment requires a box to build off
  # of. We build of Ubuntu 20.04 LTS (Focal Fossa)
  config.vm.box = "generic/ubuntu2004"

  config.vm.synced_folder "/home/sortraev/data/pcs/A3", "/home/vagrant/A3"
  config.vm.synced_folder "/home/sortraev/data/pcs/A4", "/home/vagrant/A4"
  config.vm.synced_folder "/home/sortraev/data/pcs/A6", "/home/vagrant/A6"
  config.vm.synced_folder "/home/sortraev/data/pcs/final", "/home/vagrant/final"

  config.vm.hostname = "pcs-f2023"
#  config.vm.network "forwarded_port", guest: 22, host: 2222,
#                    host_ip: "127.0.0.1", id: 'ssh'


  ############################################################
  # Provider for VirtuaBox on Intel
  ############################################################
  config.vm.provider "virtualbox" do |vb|
    vb.name = "Proactive Computer Security F2023"
    vb.memory = "4096"
    vb.cpus = 2
    # Fix console
    # https://bugs.launchpad.net/cloud-images/+bug/1829625
    vb.customize ["modifyvm", :id, "--uart1", "0x3F8", "4"]
    vb.customize ["modifyvm", :id, "--uartmode1", "file", File::NULL]

  #   # Display the VirtualBox GUI when booting the machine
  #   vb.gui = true
   end

  ############################################################
  # Provider for Docker on ARM
  ############################################################
  config.vm.provider :docker do |docker, override|
    override.vm.box = nil
    docker.image = "kflarsen/vagrant-provider:focal"
    docker.remains_running = true
    docker.has_ssh = true
    docker.privileged = true
    docker.volumes = ["/sys/fs/cgroup:/sys/fs/cgroup"]
    docker.create_args = ["--cgroupns=host"]
    # Uncomment to force arm64 for testing images on Intel
    # docker.create_args = ["--cgroupns=host", "--platform=linux/arm64"]
  end



  # Create a private network, which allows host-only access to the
  # machine using a specific IP.
  #config.vm.network "private_network", ip: "192.168.33.42"


  # Share an additional folder to the guest VM.
  # The first argument is the path on the host to the actual folder.
  # The second argument is the path on the guest to mount the folder.
  #config.vm.synced_folder "./src", "/pcs"



  # Define the script: A shell script that runs after first
  # setup of your box (= provisioning). Here using the inline script defined in
  # the top of the file.

  # Install the some useful tools and compile runshellcode.c
  config.vm.provision :shell, name: "Install PCS Tools", inline: $script

  # Add minimal .gdbinit and disable Canonical ads
  config.vm.provision :shell, name: "Add minimal .gdbinit for the normal user",
                      privileged: false, inline: <<-'SHELL'
set -xe
cat <<'EOF' > .gdbinit
# Settings
set disassembly-flavor intel
set disable-randomization off
set pagination off
set follow-fork-mode child

# History
set history filename ~/.gdbhistory
set history save
set history expansion

# Output format
#set output-radix 0x10
EOF
touch $HOME/.hushlogin
SHELL


  config.vm.post_up_message = $msg

end
