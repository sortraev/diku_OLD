\newpage
\section{Concurrency Control}

\subsection{Schedules}

\begin{itemize}
  \item \textbf{Schedules, 3.1.1:}
    \textit{Give a serializable schedule of T1, T2, and T3.}
\end{itemize}

To paraphrase from the compendium, a schedule $S_1$ is serializable if, on any
consistent database, it can be rewritten into another $S_2$ schedule which is
totally serial.
\smallskip

While some definitions of serializability do not require that
$S_1$ is not in itself a totally serial schedule, the course compendium is not
clear on this, so let's have all three transactions execute serially but
interleave their commits:

\begin{minted}{text}
T1: R(X) W(X) R(Y) W(Y)                                  C
T2:                    R(Y) W(Y) W(Z)                  C
T3:                                   R(X) R(Z) W(Z) C
\end{minted}


\begin{itemize}
  \item \textbf{Schedules, 3.1.2:}
    \textit{Give a conflict-serializable schedule of T1, T2, and
    T3.}
\end{itemize}

A schedule is conflict-serializable if its precedence graph is \textbf{aclycic}.
Let's again consider the schedule given for task \textbf{3.1.1} above:

\begin{minted}{text}
T1: R(X) W(X) R(Y) W(Y)                                  C
T2:                    R(Y) W(Y) W(Z)                  C
T3:                                   R(X) R(Z) W(Z) C
\end{minted}

This schedule is conflict-serializable. To show this, we draw the precedence
graph, which is a graph whose vertices are the three transactions, and which
contains an edge $T_i \to T_j$ whenever an action of $T_i$ precedes and
conflicts with one of $T_j$'s actions. The graph looks like so:

\begin{align*}
  V &= \{T1\, , T2\, , T3\}\\
  E &= \{T1 \to T2\, , T2 \to T3\, , T1 \to T3\}\\
\end{align*}

We see that there are no cycles in the precedence graph, and conclude that the
schedule is conflict-serializable.


\begin{itemize}
  \item \textbf{Schedules, 3.1.3:}
    \textit{Give a schedule of T1, T2, and T3 that is \textbf{not}
    conflict-serializable.}
\end{itemize}

To give a schedule that is not conflict-serializable, we simply need to insert a
cycle in the precedence graph. The below schedule is identical to the previous,
except T1's write to Y is moved after T2's write to Y:

\begin{minted}{text}
T1: R(X) W(X) R(Y)           W(Y)                         C
T2:                R(Y) W(Y)      W(Z)                  C
T3:                                    R(X) R(Z) W(Z) C
\end{minted}

The precedence graph now also contains an edge $T2 \to T1$, meaning there is a
cycle $T1 \to T2 \to T1$.

\begin{itemize}
  \item \textbf{Schedules, 3.1.4:}
    \textit{Give a conflict-serializable schedule of T1, T2, and T3 that could
    \textbf{not} have been generated by a strict 2PL scheduler with lock
  upgrades.}
\end{itemize}

To give an example of this, let's consider the completely serial schedule, but
move T3's read of X after T1's write to X, as below:

\begin{minted}{text}
T1: R(X) W(X)      R(Y) W(Y) C
T2:                            R(Y) W(Y) W(Z) C
T3:           R(X)                              R(Z) W(Z) C
\end{minted}

This schedule is conflict serializable since its precedence graph:

\begin{align*}
  V &= \{T1\, , T2\, , T3\}\\
  E &= \{T1 \to T2\, , T2 \to T3\, , T1 \to T3\}\\
\end{align*}

is still aclycic, but is could \textbf{not} have been generated by a strict 2PL
scheduler because when T3 wants to read X, it needs at least a shared lock of X,
but it cannot obtain this since T1 holds an exclusive lock, which it cannot let
go of before it commits.

\begin{itemize}
  \item \textbf{Schedules, 3.1.5:}
    \textit{Give a conflict-serializable schedule of T1, T2, and T3 that could
    have been generated by a strict 2PL scheduler with lock
  upgrades, but not by a conservative 2PL scheduler with lock downgrades.}
\end{itemize}


I give this example:

\begin{minted}{text}
T1: R(X) W(X) R(Y) W(Y) C
T2:                       R(Y) W(Y)                  W(Z) C
T3:                                 R(X) R(Z) W(Z) C
\end{minted}

The schedule has the following precedence graph:

\begin{align*}
  V &= \{T1\, , T2\, , T3\}\\
  E &= \{T1 \to T2\, , T1 \to T3\, , T3 \to T2\}
\end{align*}

which is aclycic, so the schedule is conflict-serializable.
\medskip

The schedule could have been produced by a S2PL scheduler, since T3 does not
need the lock on Y, and because T3 releases the exclusive lock on Z before T2
needs it. \medskip

However, it could not have been produced by a C2PL scheduler, since T2 cannot
perform its read and write of Y before it has also acquired the lock on Z, which
it does not obtain until T3 has released it.

\sectend

\subsection{Deadlocks}

\begin{itemize}
  \item \textbf{Deadlocks, 3.2.1:}
    \textit{Which of the 2PL variants can result in deadlocks? Explain why and
    give a schedule with a deadlock. Explain why other variants cannot generate
  deadlocks.}
\end{itemize}

Strict two-phase locking can produce deadlocks, since it begins execution before
it has acquired all locks, and does not let go of any of them before it commits.
If two transactions begins execution before they have acquired all necessary
locks, they might end up in a situation where they need a lock held by the
other, but neither of them can release the lock needed by the other transaction.
\smallskip

Below schedule is an example of this, where \ms{S(A)} and \ms{X(A)} means shared
and exclusive locks of \ms{A}:

\begin{minted}{text}
T1:           X(C)           X(A)
T2:      X(B)           X(C)
T3: S(A)           S(B)
\end{minted}

Here, T3 waits for T2's lock on B; T2 waits for T1's lock on C; and T1 waits for
T3's lock on A.
\medskip

Other 2PL variants which gather all locks before they start execution cannot
produce deadlocks, since this would imply that they will never be in a situation
where they are both holding locks and waiting for other locks.


\begin{itemize}
  \item \textbf{Deadlocks, 3.2.2:}
    \textit{Which of the two strategies prevent deadlocks? For those that do,
    explain why, and else give a counterexample schedule.}
\end{itemize}

\paragraph{Both strategies} succeed. Since locks are atomic, only one
transaction can request a given lock at a time, meaning only that transaction
can be responsible for a deadlock at a time. Removing one node from a cycle is
sufficient to break that cycle and thus the deadlock.

\Sectend
