\newpage
\section{More concurrency control}

Consider the below two schedules:

\begin{minted}{text}
Schedule 1
Ta: R(X)                         W(X) C
Tb:      R(X) W(Y)      C
Tc:                R(X)   W(Y) C
\end{minted}

\begin{minted}{text}
Schedule 2
Ta: R(X)                              W(Z) C
Tb:      R(Z) R(Y) W(Y) C
Tc:                       R(X) W(X) C
\end{minted}

\begin{itemize}
  \item \textit{1. Could schedule 1 have been generated by an S2PL scheduler?}
\end{itemize}

Yes! With lock conversion, a transaction can upgrade its shared lock to an
exclusive lock of the same resource if no other transaction holds a shared lock
of that resoruce. If we assume lock conversion is possible, then schedule 1
could have been generated by a strict 2PL scheduler as shown below:

\begin{minted}{text}
Schedule 1
Ta: S(X) R(X)                                             X(X) W(X) C
Tb:           S(X) X(Y) R(X) W(Y)           C
Tc:                               S(X) R(X)   X(Y) W(Y) C
\end{minted}

Notice that \ms{Ta} first acquires a shared lock of \ms{X}, and only upgrades
this to an exclusive lock when necessary. In the meantime \ms{Tb} is able to
both grab a shared lock of \ms{X} and release it again.

\streg

\begin{itemize}
  \item \textit{2. Could schedule 1 have been generated by an 2PL scheduler?}
\end{itemize}

Yes! Any schedule that can be produced by a strict 2PL scheduler can also be
produced by a 2PL scheduler, so the same reasoning as before can be used here.

\streg

\begin{itemize}
  \item \textit{3. Could schedule 2 have been generated by a C2PL scheduler?}
\end{itemize}

No! \ms{Ta} cannot make its read of \ms{X} before it has acquired all the locks
it will need, but it will need an exclusive lock for \ms{Z}, and this will
prevent \ms{Tb} to acquire a shared lock of \ms{Z}.


\streg

\begin{itemize}
  \item \textit{4. Could schedule 2 have been generated by a Kung-Robinson
    scheduler?}
\end{itemize}

Short answer: no!

Slightly longer answer: In Kung-Robinson, transactions are assigned ID's at the
end of their read phases, and when validating transactions, any given
transaction is compared to transactions which ended their read phases later.
\medskip

In the snippet below, I have inserted vertical bars to annotate where I assume
read phases to end:


\begin{minted}{text}
Schedule 2
Ta: R(X) |                                  W(Z) C
Tb:        R(Z) R(Y) | W(Y) C
Tc:                           R(X) | W(X) C
\end{minted}

This would indicate that I should start by validating \ms{Ta}.

\pargraph{Validating \texttt{Ta}}~\smallskip

Both \ms{Tb} and \ms{Tc} begin before \ms{Ta} ends, so test 1 fails. \smallskip

Both \ms{Tb} and \ms{Tc} also start their write phases before \ms{Ta} completes,
so test 2 fails aswell. \smallskip

\ms{Ta} completes its read phase before both \ms{Tb} and \ms{Tc} do, but the
condition that \ms{WriteSet(Ta)} must not overlap with \ms{ReadSet(Tx)} or
\ms{WriteSet(Tx)} holds for neither \ms{Tx = Tb} or \ms{Tx = Tc}.
\medskip

Since we have already invalidated \ms{Ta}, there is no reason to examine the
other transactions.

\tykstreg
