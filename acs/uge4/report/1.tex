\section{Concurrency Control Concepts}


\begin{itemize}
  \item \textit{1. Show a schedule that is view-serializable, but not
  conflict-serializable.}
\end{itemize}

I try to devise as simple a schedule as possible that still meets the
specifications:

\begin{minted}{text}
View-serializable, non-conflict-serializable schedule

T1:      W(A)
T2: R(A)      W(A)
T3:                W(A)
\end{minted}

The schedule shown is \textit{not} conflict-serializable because there is a
cycle in its precedence graph (\ms{T2 -> T1 -> T2}). \medskip

Consider then the dependency graph for the schedule. Since \ms{T2} and \ms{T1}
make the first read and update of \ms{A}, respectively, \ms{T1} must execute
before \ms{T2}, producing the dependency \ms{T1 -> T2}. \smallskip

Since \ms{T3} makes the last update of \ms{A}, it must come after all other
transactions which update \ms{A} (ie. both \ms{T1} and \ms{T2}), producing the
dependencies \ms{T1 -> T3} and \ms{T2 -> T3}. Since there are no
write-before-read conflict to be considered, the dependency graph is:

\begin{minted}{text}
T1 ----------> T2
\              /
 \---> T3 <---/
\end{minted}

There are no cycles in the dependency graph, so the schedule must be
view-serializable.

\streg

\begin{itemize}
  \item \textit{2. Show a schedule that is conflict-serializable, but which
    could not have been generated by an S2PL scheduler.}
\end{itemize}

Consider below schedule in which two transactions access the same variable
\ms{B}, and where one also reads a different variable. \ms{S(V)}
and \ms{X(V)} denote shared and exclusive locks on some variable \ms{V}. Assume
that locks are implicitly unlocked in \ms{C}.

\begin{minted}{text}
Conflict-serializable, non-S2PL schedule

T1: X(B) W(B)             S(A) R(A) C
T2:           S(B) R(B) C
\end{minted}

The precedence graph for this schedule contains simply one edge from \ms{T1} to
\ms{T2}, corresponding to the write-after-write conflict on \ms{B}.\medskip

However, it could not have been produced by an S2PL scheduler, since \ms{T1}
cannot release its exclusive lock on \ms{B} before it has committed.

\streg

\begin{itemize}
  \item \textit{3. Show a schedule that could be generated by an S2PL scheduler,
    but not by a C2PL scheduler.}
\end{itemize}


Consider below schedule in which two transactions access two variables \ms{A}
and \ms{B} (once again, locks are implicitly released in \ms{C}):

\begin{minted}{text}
S2PL, non-C2PL schedule. Locks are implicitly unlocked in C.

T1: S(A) R(A)             S(B) R(B) C
T2:           X(B) W(B) C
\end{minted}


This could have been generated by an S2PL scheduler with the inserted locks. It
is a valid S2PL schedule since \ms{T1} does not have to acquire the shared lock
on \ms{B} before it can make the read to \ms{A}. However, it is \textit{not}
a valid C2PL schedule for the exactly the opposite reason: the read of \ms{A}
before \ms{T1} has the shared lock on \ms{B} is not legal in C2PL.

\streg

\begin{itemize}
  \item \textit{4. Show a schedule that could be generated by a C2PL scheduler,
    but not by an S2PL scheduler.}
\end{itemize}

In the below schedule, \ms{U(V)} denotes the explicit unlocking of some lock
\ms{V}, but \ms{C} still implicitly unlocks all locks still held at commit time.

\begin{minted}{text}
C2PL, non-S2PL schedule

T1: S(A) S(B) R(A) U(A)             R(B) C
T2:                     X(A) W(A) C
\end{minted}


Conservative 2PL requires that \ms{T1} gathers shraed locks on both \ms{A} and
\ms{B} before begings its read of \ms{A}; however, \ms{T1} is allowed to release
its lock on \ms{A} before reading \ms{B}, and thus \ms{T2} is able to grab the
lock on \ms{A} before \ms{T1} has read \ms{B}.
\medskip

However, it is precisely for this reason that this schedule could \textit{not}
have been generated by an S2PL scheduler; here, \ms{T1} would not have been able
to release its lock on \ms{A} before it had also locked and read \ms{B}.



\tykstreg
